# 第一章——区块链技术入门

跳过前期区块链介绍等废话

声明：我知道hash值是16进制的，所有不应该有g以后的字母，但是我都是乱按键盘的，所以请哥哥姐姐们不要在意！

## 第五课：使用非对称加密技术确定所有权

### 一、私钥

核心：如何在不泄露所有权的情况下证明所有权：非对称加密

```js
const yourAdress = "2A39cbA2390fDe"
const yourPraviteKey = "GJKGTOUHKJHuiTyihotr"
Hash(Hash(fun("GJKGTOUHKJHuiTyihotr")))   ->  "2A39cbA2390fDe"  #私钥可以推地址，而地址不能推私钥
```

### 二：交易的处理流程

交易发起者签名后广播至相邻节点→相邻节点验证是否有效→继续广播

#### 1.对交易签名签名

```js
hash('
     {"fromAddress":"2A39cbA2390fDe",
     "toAddress":"3aDF789cdjkLcRf",
     "sum":"0.8btc"
     }'
    )  -> "8aDb23CDEa6"  #对一个交易进行hash运算产生交易摘要

sign("8aDb23CDEa6","GJKGTOUHKJHuiTyihotr") -> "sd7854hctgf9" 
#用私钥对交易摘要进行签名，返回签名信息，该操作通常在离线环境下完成
```

#### 2.签名后广播

签名后广播（`交易信息` + `签名信息`）至相邻节点 ，相邻节点验证后保存到本地，然后继续广播

```js
#验证过程：
即：verify("sd7854hctgf9","3aDF789cdjkLcRf") -> "8aDb23CDEa6"

if(verify("sd7854hctgf9","3aDF789cdjkLcRf")
   == hash('
     {"fromAddress":"2A39cbA2390fDe",
     "toAddress":"3aDF789cdjkLcRf",
     "sum":"0.8btc"
     }'
    )):
	#写入账本，继续广播
 else:
 	# 啥都不做
```

### 三.补充

1. 关于隐私：地址和自然人的对应关系不是公开的
2. 关于安全：私钥只有自己知道

##  第六课：使用区块链结构高效验证数据

#### 一、问题

由于数据是分布式存储的，如果单个节点篡改数据，如何验证数据真实？

#### 二、方法：验证账本的hash值

Hash 函数：Hash（原始信息） =  摘要信息

- 同样的原始信息使用同一个哈希函数总能得到同样的摘要信息	
- 原始信息的微小变动会使摘要信息面目全非
- 无法从摘要信息逆推出原始信息

#### 三、具体解决方案：

```js
info_need_verify = Hash(Hash(blockFatherId,blockFatherInfo,time),blockId,blockInfo,timenow) = "7875Agc"
#即对上一个区块的Hash值，当前区块id，当前区块的账本信息，时间戳共4个参数进行hash运算得到hash值
#只需对info_need_verify进行校验即可，效率贼高！
#由于每个区块的info_need_verify都含有上一个区块的信息，可以依次向前验证
```



## 第七课：使用工作量证明进行挖矿

### 一、记账的规则

- 一段时间内只有一个人可以记账成功
- 通过解决密码学难题（pow）竞争获得唯一记账权
- 其他节点复制记账结果
- 记账可以获得比特币奖励，即对记账的激励

### 二、工作量证明

``` js
# 普通的记账过程
Hash(Hash(blockFatherId,blockFatherInfo,time),blockId,blockInfo,timenow) = "7875Agc"
#加入工作量证明的记账过程
 #通过在Hash函数里面加入随机数参数增加难度，要求生成前x位为0的Hash值。x越大，难度越高。
 #简单来说，该过程没有任何技巧可言，如果希望尽快找到解，除堆积算力外没有其他方法
const x = 24  #根据目前参与挖矿的算力的大小选择合适的x设定挖矿难度
Hash(Hash(blockFatherId,blockFatherInfo,time,random()),blockId,blockInfo,timenow,random()) = "0" * x +"495CD6FH"
```

完成上述过程后：

 	1. 收集广播中还没有被记录到账本的交易
 	2. 验证收集的交易的有消息
 	3. 添加一笔"fromAddress" == Null & "toAddress" == yourself 的交易，作为挖矿的奖励

### 三、工作量证明的计算量到底有多大

Hash值为16进制的字符串，则1个为0的概率为1/16，如果需要前x位同时为0，概率为(1/16)^x

## 第八课：共识机制

### 一、为什么节点要遵守协议？

- 节点的工作量只有在其他节点认可的时候才是有效的

### 二、如何解决分叉问题？

在产生一个新的区块时，第二个节点挖到矿时还没有覆盖超过50%的节点

（信息的传播是需要时间的，离得越近传播的越快）

- 每个节点独立选择，在选择是同时将另外一个区块作为备胎
- 每个正常的节点都会选择延长最长链，且只认可最长链（所以在短的链上面继续挖矿单纯浪费算力）

## 第九课：p2p网络的节点如何连接

- 节点会记住连接信息，即连接过一次后，节点会保存这部分连接的信息
- 节点加入后会向相邻的节点广播，相邻节点会继续向他们的相邻节点广播
- 节点加入后会向邻居节点索要其连接信息，即节点之前相互引荐
- 若节点加入时没有任何已知节点可以相连，则会连接至种子节点（网络内保存活跃的节点），然后重复上述3条



## 第十课：智能合约的革命性

### 一、背景：

比特币的智能合约编程是图灵不完备的，基于比特币的区块链开发需要下载比特币的源码，然后在其中修改加密算法、共识机制等，相对复杂且局限。

### 二、以太坊：

下一代智能合约和去中心化应用平台，类似android、ios等

特点：

- 支持高级语音编程（智能合约）
- 每15s出一个区块，更快的区块确认时间，更多的每秒交易量
- 图灵完备
- 无总量限制（比特币的上限是2100万）

### 三、智能合约

- 以太坊上的程序，是代码和数据（状态）的集合，是消息驱动的
- Code is Law，其执行像法律一样，执行不受任何人的干扰
- （准）图灵完备

## 第十一课：不一样的区块链-EOS

### 一、背景

以太坊的局限性：交易的确认时间和交易的吞吐量很小（TPS）

### 二、EOS:Enterprise Operation System

致力于打造可以承载商业级区块链的平台，但是共识机制是DPOS，不是真正意义的去中心化。

特点：

- 使用石墨烯技术提高TPS

  石墨烯技术：跟石墨烯本人没有关系，只是将共识机制改为了DPOS(类似人民代表大会制度)，交易确认速度更快，

  ​			    TPS已经接近MySql的量级。

- 有完整的账号系统，即有字符串形式的账号作为地址，而不是一串"2A39cbA2390fDe"。

- 在链上的读写操作无需消耗代币，但是需要抵押代币来获得资源，再用资源去进行操作。
